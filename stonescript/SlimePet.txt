var slimeFrames = [
ascii
##.——.
#( • •)
asciiend,
ascii
###.—.
##(• •)
asciiend,
ascii
#______
(  • • ) 
asciiend
]

// config
var jumpLength = 10.0
var jumpHeight = 5
var slimeTargetZ = 22

// init vars
var slimeY = 0
var slimeZ = 0
var slimeX = 0
var slimeDrawY = 0
var lastPlayerX = 0
var lastPlayerZ = 0

// ai
var slimeAI = 0
var slimeState = 0
var slimeFrame = 0

?loc.loop | loc.begin
  slimeState = 0

// init
?slimeState = 0
  slimeState = 1
  slimeAI = 0
  // init start position
  slimeX = -11
  slimeTargetZ = pos.z + 1

// chilling
:?slimeState = 1
  slimeFrame = 0
  
  ?slimeX < -20
    jumpLength = 15.0
  :
    jumpLength = 10.0

  ?slimeX < -15
    slimeState = 2
    slimeAI = 0

// charge jump
:?slimeState = 2
  slimeAI++
  // switch slimeFrame every 5 ticks
  slimeFrame = math.FloorToInt(slimeAI / 3) % 2
  ?slimeAI > 15
    slimeAI = 0
    slimeState = 3
// jump
:?slimeState = 3
  slimeFrame = 1

  slimeAI++
  // Sin arc jump
  slimeY = -math.Sin((slimeAI / jumpLength) * 
  ^math.pi) * jumpHeight
  slimeY = math.RoundToInt(slimeY)

  slimeX++

  ?slimeAI > jumpLength
    slimeState = 4
    slimeAI = 0
    slimeY = 0 
    // random offset -1 to 1
    slimeZ = math.Round((rng / 9999) * 2) - 1 

// land
:?slimeState = 4
  slimeFrame = 2
  slimeAI++

  ?slimeAI > 5
    slimeState = 1
    slimeAI = 0

// increment distance from player
?slimeState ! 0
  slimeX = slimeX - (pos.x - lastPlayerX)

// tp if too far
?slimeX < -50
  slimeX = -20

slimeDrawY = slimeTargetZ - pos.z + 
^slimeY + slimeZ

// manage player vars 
lastPlayerX = pos.x
lastPlayerZ = pos.z

// draw relative to player
>o@slimeX@,@slimeDrawY@,#green,
^@slimeFrames[slimeFrame]@